# MynaAPI - Backend Service Design & Architecture

## Project Overview
MynaAPI is a backend service that assists school students in finding the best colleges based on their academic marks. The system uses Agentic AI with LangGraph to process user queries and provide intelligent responses.

## Technology Stack
- Python (Latest stable version)
- Virtual Environment (venv)
- LangGraph for Agentic AI implementation
- OpenAI GPT-4.0 for natural language processing
- Pinecone as Vector Database for RAG implementation
- REST API for mobile app integration
- FastAPI for web framework
- Logging system for comprehensive monitoring

## Architecture Components

### 1. Authentication Layer
- Username/Password based authentication for mobile app integration
- JWT token generation and validation
- Middleware for API endpoint protection

### 2. Agentic AI Framework (LangGraph)
The system implements a multi-node architecture:

#### Router Node (Entry Point)
- Receives user queries from mobile app
- Connects to GPT-4.0 for intent understanding
- Routes queries to appropriate specialized nodes
- Maintains conversation context and metadata

#### TNEA Node (Tamil Nadu Engineering Admissions)
- Handles queries related to engineering college admissions in Tamil Nadu
- Implements RAG (Retrieval Augmented Generation) using Pinecone
- Provides cutoff mark-based college recommendations
- Uses vector similarity search for relevant information retrieval

#### Future Implementation Node
- Placeholder for queries not handled by current nodes
- Designed for extensibility to accommodate future specialized nodes
- Returns appropriate "coming soon" responses

### 3. Data Layer
#### Pinecone Vector Database
- Index: mynaservice
- Stores vectorized college and admission data
- Enables semantic search for RAG implementation
- Host: https://mynaservice-uf7j9ag.svc.aped-4627-b74a.pinecone.io

### 4. Context Management
- User session management
- Conversation history tracking
- Metadata preservation across node transitions
- Memory persistence for personalized responses

### 5. Logging System
- Comprehensive request/response logging
- Node routing information
- System integration tracking
- Error monitoring and debugging capabilities
- Log file rotation and management

### 6. Configuration Management
- Environment variables in .env file
- API keys and database credentials
- Configurable model parameters
- Deployment-specific settings

## API Endpoints

### Authentication
- POST /auth/login - User authentication
- POST /auth/refresh - Token refresh

### Query Processing
- POST /api/query - Main query endpoint
- GET /api/health - Health check
- GET /api/logs - Log retrieval (admin)

## Project Structure
```
MynaAPI/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI application entry point
│   ├── config/
│   │   ├── __init__.py
│   │   └── settings.py         # Configuration management
│   ├── auth/
│   │   ├── __init__.py
│   │   ├── models.py           # User models
│   │   ├── routes.py           # Authentication routes
│   │   └── utils.py            # Auth utilities
│   ├── agents/
│   │   ├── __init__.py
│   │   ├── graph.py            # LangGraph implementation
│   │   ├── nodes/
│   │   │   ├── __init__.py
│   │   │   ├── router_node.py  # Router node implementation
│   │   │   ├── tnea_node.py    # TNEA node implementation
│   │   │   └── future_node.py  # Future implementation node
│   │   └── utils.py            # Agent utilities
│   ├── services/
│   │   ├── __init__.py
│   │   ├── openai_service.py   # OpenAI integration
│   │   ├── pinecone_service.py # Pinecone integration
│   │   └── logging_service.py  # Logging utilities
│   ├── models/
│   │   ├── __init__.py
│   │   ├── request_models.py   # Pydantic request models
│   │   └── response_models.py  # Pydantic response models
│   └── utils/
│       ├── __init__.py
│       └── helpers.py          # General utilities
├── tests/
│   ├── __init__.py
│   ├── test_auth.py
│   ├── test_agents.py
│   └── test_services.py
├── logs/                       # Log files directory
├── requirements.txt
├── .env                        # Environment variables
├── .gitignore
├── README.md
└── run.py                      # Application runner
```

## Data Flow
1. Mobile app sends authenticated request to /api/query
2. Request reaches Router Node in LangGraph
3. Router Node uses GPT-4.0 to analyze intent
4. Based on intent, routes to appropriate node:
   - TNEA-related queries → TNEA Node
   - Other queries → Future Implementation Node
5. TNEA Node performs RAG using Pinecone for relevant data
6. Node generates response using GPT-4.0
7. Response sent back through the graph maintaining context
8. Final response returned to mobile app
9. All interactions logged for monitoring

## Security Considerations
- API key management through environment variables
- JWT-based authentication
- Request rate limiting
- Input validation and sanitization
- Secure logging (no sensitive data in logs)

## Deployment Considerations
- Environment-specific configuration
- Docker containerization support
- Cloud deployment readiness
- Scalability for multiple concurrent users
- Health monitoring endpoints

## Extension Points
- New node types can be easily added to the LangGraph
- Router logic can be extended for new intents
- Additional vector databases can be integrated
- Multiple authentication methods can be supported

## Configuration Files

### .env File Contents
```
OPENAI_API_KEY=your-openai-api-key-here
PINECONE_API_KEY=your-pinecone-api-key-here
PINECONE_HOST=your-pinecone-host-url-here
PINECONE_INDEX=your-pinecone-index-name
JWT_SECRET_KEY=your-secret-key-here
JWT_ALGORITHM=HS256
JWT_EXPIRATION_HOURS=24
LOG_LEVEL=INFO
```

## Development Phases
1. Phase 1: Basic project structure and authentication
2. Phase 2: LangGraph implementation with Router and Future nodes
3. Phase 3: TNEA Node with Pinecone RAG integration
4. Phase 4: Comprehensive logging and monitoring
5. Phase 5: Testing and optimization
6. Phase 6: Documentation and deployment preparation
7. Phase 7: Azure Container deployment and production setup

## Azure Deployment Architecture

### Overview
The MynaAPI will be deployed on Azure using a containerized approach with Azure Container Instances (ACI) or Azure Container Apps for optimal scalability, cost-effectiveness, and ease of management.

### Deployment Strategy Options

#### Option 1: Azure Container Instances (ACI) - Recommended for Development/Testing
- **Service**: Azure Container Instances
- **Benefits**: Simple deployment, serverless containers, pay-per-second billing
- **Best For**: Development, testing, low-traffic production environments
- **Scaling**: Manual scaling with multiple container groups

#### Option 2: Azure Container Apps - Recommended for Production
- **Service**: Azure Container Apps
- **Benefits**: Auto-scaling, managed Kubernetes, built-in monitoring
- **Best For**: Production environments requiring high availability and auto-scaling
- **Scaling**: Automatic horizontal scaling based on HTTP traffic or custom metrics

#### Option 3: Azure Kubernetes Service (AKS) - Enterprise Scale
- **Service**: Azure Kubernetes Service
- **Benefits**: Full Kubernetes features, maximum control, enterprise-grade
- **Best For**: Large-scale production with complex orchestration needs
- **Scaling**: Advanced orchestration with Kubernetes features

### Container Architecture

#### Base Container Configuration
- **Base Image**: python:3.13-slim
- **Application Port**: 8000
- **Health Check**: /health endpoint
- **Resource Requirements**: 
  - CPU: 0.5-2 cores
  - Memory: 1-4 GB
  - Storage: 10 GB temporary

#### Environment Variables Management
- **Azure Key Vault**: Store sensitive API keys securely
- **Container Environment Variables**: Non-sensitive configuration
- **Managed Identity**: Secure access to Azure services without credentials

### Infrastructure Components

#### 1. Container Registry
- **Service**: Azure Container Registry (ACR)
- **Purpose**: Store and manage Docker images
- **Features**: Geo-replication, vulnerability scanning, automated builds

#### 2. Application Gateway / Load Balancer
- **Service**: Azure Application Gateway or Azure Load Balancer
- **Purpose**: Traffic distribution, SSL termination, WAF protection
- **Features**: Auto-scaling, health probes, custom domains

#### 3. Monitoring and Logging
- **Service**: Azure Monitor + Application Insights
- **Purpose**: Performance monitoring, error tracking, distributed tracing
- **Features**: Custom metrics, alerts, log analytics

#### 4. Security
- **Service**: Azure Key Vault + Managed Identity
- **Purpose**: Secure secrets management and authentication
- **Features**: Automatic key rotation, access policies, audit logs

#### 5. Database and Storage
- **External Services**: OpenAI API, Pinecone Vector DB
- **Caching**: Azure Cache for Redis (optional for performance)
- **File Storage**: Azure Blob Storage (for logs and static files)

### Deployment Process

#### 1. Containerization
```dockerfile
# Multi-stage build for optimization
FROM python:3.13-slim as builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --user -r requirements.txt

FROM python:3.13-slim
WORKDIR /app
COPY --from=builder /root/.local /root/.local
COPY . .
EXPOSE 8000
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

#### 2. CI/CD Pipeline (GitHub Actions)
```yaml
# Automated build and deployment
- Build Docker image
- Push to Azure Container Registry
- Deploy to Azure Container Apps
- Run health checks
- Rollback on failure
```

#### 3. Infrastructure as Code (ARM Templates / Bicep)
```bicep
# Azure Resource Manager templates
- Container Apps Environment
- Application Gateway
- Key Vault
- Monitoring components
- Networking (VNet, subnets)
```

### Scaling and Performance

#### Auto-scaling Configuration
- **Trigger**: HTTP request volume, CPU usage, memory usage
- **Min Instances**: 1
- **Max Instances**: 10
- **Scale-out Threshold**: 70% CPU or 100 concurrent requests
- **Scale-in Threshold**: 30% CPU or 20 concurrent requests

#### Performance Optimization
- **Connection Pooling**: Optimized HTTP client connections
- **Caching**: Redis for frequently accessed data
- **CDN**: Azure CDN for static content delivery
- **Geographic Distribution**: Multi-region deployment for global users

### Security Implementation

#### Network Security
- **Virtual Network**: Isolated network environment
- **Network Security Groups**: Firewall rules
- **Private Endpoints**: Secure connections to Azure services
- **DDoS Protection**: Azure DDoS Protection Standard

#### Application Security
- **Managed Identity**: Azure AD authentication for services
- **Key Vault Integration**: Secure API key management
- **SSL/TLS**: End-to-end encryption
- **Web Application Firewall**: Protection against common attacks

#### Compliance and Auditing
- **Azure Policy**: Governance and compliance enforcement
- **Activity Logs**: Comprehensive audit trail
- **Security Center**: Continuous security assessment
- **Backup and Recovery**: Automated backup strategies

### Cost Optimization

#### Resource Management
- **Right-sizing**: Optimize container resources based on usage
- **Reserved Instances**: Commit to long-term usage for discounts
- **Spot Instances**: Use for non-critical workloads
- **Auto-shutdown**: Schedule for development environments

#### Monitoring and Alerts
- **Cost Alerts**: Budget thresholds and notifications
- **Usage Analytics**: Track resource consumption patterns
- **Optimization Recommendations**: Azure Advisor suggestions

### Disaster Recovery and Business Continuity

#### Backup Strategy
- **Application Code**: Git repository backup
- **Configuration**: Infrastructure as Code templates
- **Logs**: Azure Monitor long-term retention
- **Secrets**: Key Vault geo-replication

#### High Availability
- **Multi-Zone Deployment**: Availability zones for redundancy
- **Health Checks**: Automated failure detection
- **Failover**: Automatic traffic redirection
- **Recovery Time Objective (RTO)**: < 5 minutes
- **Recovery Point Objective (RPO)**: < 1 minute

### Deployment Environments

#### Development Environment
- **Service**: Azure Container Instances
- **Resources**: 0.5 CPU, 1 GB RAM
- **Features**: Basic logging, development API keys
- **Cost**: ~$20-30/month

#### Staging Environment
- **Service**: Azure Container Apps (single instance)
- **Resources**: 1 CPU, 2 GB RAM
- **Features**: Production-like configuration, test data
- **Cost**: ~$50-70/month

#### Production Environment
- **Service**: Azure Container Apps (auto-scaling)
- **Resources**: 1-4 CPU, 2-8 GB RAM (dynamic)
- **Features**: Full monitoring, production API keys, high availability
- **Cost**: ~$100-300/month (depending on usage)

### Migration and Rollout Strategy

#### Phase 1: Initial Deployment
- Deploy to development environment
- Validate functionality and performance
- Configure monitoring and alerting

#### Phase 2: Staging Validation
- Deploy to staging environment
- Conduct load testing and security validation
- Verify integrations with external services

#### Phase 3: Production Rollout
- Blue-green deployment to production
- Gradual traffic migration (10%, 50%, 100%)
- Monitor performance and error rates

#### Phase 4: Optimization
- Analyze performance metrics
- Optimize resource allocation
- Implement cost optimization strategies

This comprehensive Azure deployment strategy ensures scalability, security, and cost-effectiveness while maintaining high availability and performance for the MynaAPI service.

## DEPLOYMENT IMPLEMENTATION LOG
*Last Updated: August 17, 2025*

### Successful Deployment Summary
- **Deployment Method**: Option A - Automated CI/CD via GitHub Actions (Azure Container Apps)
- **Target Environment**: Development
- **Final Deployment URL**: https://mynaapi-dev-app.whitesea-4e83e951.eastus.azurecontainerapps.io
- **Status**: ✅ SUCCESSFULLY DEPLOYED AND OPERATIONAL

### Infrastructure Created
1. **Azure Container Registry**: `mynaapidevacr.azurecr.io`
2. **Azure Key Vault**: `mynaapi-dev-kv`
3. **Container Apps Environment**: `mynaapi-dev-env`
4. **Container App**: `mynaapi-dev-app`
5. **GitHub Actions CI/CD Pipeline**: Automated build and deployment

### Critical Issues Resolved During Deployment

#### 1. Python Dependencies Compatibility Issues
**Problem**: Multiple dependency conflicts between packages
- pydantic version conflicts with langchain
- requests package compatibility issues
- langgraph dependency resolution failures

**Solution**: Updated requirements.txt with compatible versions
```
pydantic>=2.7.4
langchain>=0.3.0
langchain-core>=0.3.72
requests>=2.32.3
```

**Files Modified**: `requirements.txt`

#### 2. GitHub Actions Security Scanning Issues
**Problem**: CodeQL security scan failing due to outdated version
**Solution**: Upgraded to CodeQL v3 in GitHub Actions workflow
```yaml
- uses: github/codeql-action/init@v3
- uses: github/codeql-action/analyze@v3
```

**Files Modified**: `.github/workflows/azure-deploy.yml`

#### 3. ARM Template Timeout and Complexity
**Problem**: ARM template deployment timing out due to Container App complexity
**Solution**: Simplified ARM template approach:
- Removed Container App from ARM template
- Created Container App via Azure CLI commands in workflow
- Separated infrastructure and application deployment phases

**Files Modified**: 
- `deployment/azure/main.json` (simplified)
- `.github/workflows/azure-deploy.yml` (added CLI commands)

#### 4. Azure Container Registry Authentication
**Problem**: Service Principal lacked permissions to assign roles for Container App authentication
**Solution**: Used ACR admin credentials instead of role-based authentication
```bash
az acr update --name mynaapidevacr --admin-enabled true
```

**Files Modified**: `.github/workflows/azure-deploy.yml`

#### 5. Container App Registry Configuration Syntax
**Problem**: Azure CLI syntax error when setting registry credentials
```bash
# INCORRECT SYNTAX (caused error)
az containerapp update --registry-server --registry-username --registry-password

# CORRECT SYNTAX (working solution)
az containerapp update --image <image-name>
az containerapp registry set --server <server> --username <user> --password <pass>
```

**Solution**: Split into separate commands for image update and registry configuration

**Files Modified**: `.github/workflows/azure-deploy.yml`

#### 6. Docker Multi-Stage Build Permission Issues
**Problem**: uvicorn module not found due to permission issues between build stages
- Python packages installed in `/root/.local` during build stage
- Runtime stage used non-root user without access to packages

**Solution**: Simplified Dockerfile to single-stage build with global package installation
```dockerfile
# BEFORE (Multi-stage with permission issues)
FROM python:3.13-slim as builder
RUN pip install --user -r requirements.txt
COPY --from=builder /root/.local /root/.local
USER appuser

# AFTER (Single-stage with global packages)
FROM python:3.13-slim
RUN pip install --no-cache-dir -r requirements.txt
# Run as root for simplicity in development
```

**Files Modified**: `Dockerfile`

#### 7. Container App Port Configuration
**Problem**: Container App configured with default port 80, but FastAPI runs on port 8000
**Solution**: Updated ingress target port to 8000
```bash
az containerapp ingress update --name mynaapi-dev-app --target-port 8000
```

#### 8. Missing Environment Variables
**Problem**: Application startup failure due to missing required environment variables
```
4 validation errors for Settings
openai_api_key: Field required
pinecone_api_key: Field required
pinecone_host: Field required
pinecone_index: Field required
```

**Solution**: Added placeholder environment variables for development deployment
```bash
az containerapp update --set-env-vars OPENAI_API_KEY=placeholder PINECONE_API_KEY=placeholder PINECONE_HOST=placeholder PINECONE_INDEX=placeholder
```

### Deployment Architecture Implemented

#### GitHub Actions Workflow Structure
1. **Build and Test Phase**
   - Code checkout and Python setup
   - Dependency installation and testing
   - Docker image build and push to ACR

2. **Infrastructure Deployment Phase**
   - ARM template deployment (ACR, Key Vault, Container Apps Environment)
   - Resource group and managed identity creation

3. **Application Deployment Phase**
   - Container App creation with nginx placeholder
   - ACR credential configuration
   - Container App image update with MynaAPI
   - Environment variable configuration

#### Final Working Configuration
- **Base Image**: `python:3.13-slim`
- **Application Port**: 8000
- **Container Resources**: 1 CPU, 2Gi memory
- **Scaling**: 1-3 replicas
- **Health Check**: `/health` endpoint
- **External Access**: HTTPS with Azure-provided SSL

### Testing and Validation
#### Successful Endpoints
- **Root Endpoint**: `/` - Returns welcome message ✅
- **Health Check**: `/health` - Service status validation ✅
- **API Documentation**: `/docs` - Interactive Swagger UI ✅

#### Response Examples
```json
# GET /
{
  "message": "Welcome to MynaAPI - College Recommendation Service",
  "version": "1.0.0",
  "status": "active",
  "timestamp": "2025-08-17T14:38:48.054759"
}

# GET /health
{
  "status": "healthy",
  "timestamp": "2025-08-17T14:39:02.031657",
  "services": {
    "api": "healthy",
    "openai": "healthy",
    "pinecone": "healthy",
    "logging": "healthy"
  },
  "version": "1.0.0"
}
```

### Key Learnings and Best Practices

#### 1. Dependency Management
- Always specify compatible version ranges for Python packages
- Test dependency combinations in clean environments
- Use requirements.txt with pinned versions for reproducible builds

#### 2. Azure Container Apps Authentication
- ACR admin credentials are simpler for development than role-based authentication
- Service Principal permissions for role assignment require elevated privileges
- Container registry credentials must be set separately from image updates

#### 3. Docker Containerization
- Avoid complex multi-stage builds for simple applications
- Global package installation is more reliable than user-specific installations
- Root user is acceptable for development environments

#### 4. CI/CD Pipeline Design
- Separate infrastructure and application deployment phases
- Use ARM templates for infrastructure, CLI commands for application updates
- Implement proper error handling and rollback strategies

#### 5. Environment Configuration
- Always provide required environment variables, even as placeholders
- Use Azure Key Vault for production secrets management
- Test application startup with minimal configuration first

### Production Readiness Checklist
For production deployment, the following should be implemented:

#### Security Enhancements
- [ ] Replace placeholder environment variables with real API keys
- [ ] Implement Azure Key Vault integration for secrets
- [ ] Configure managed identity for secure Azure service access
- [ ] Enable Container Apps authentication and authorization

#### Performance and Reliability
- [ ] Implement proper health check endpoints
- [ ] Configure application insights and monitoring
- [ ] Set up automated alerts and notifications
- [ ] Implement proper logging and error tracking

#### Scalability and Maintenance
- [ ] Configure auto-scaling rules based on metrics
- [ ] Implement blue-green deployment strategy
- [ ] Set up automated backup and disaster recovery
- [ ] Configure custom domain and SSL certificates

### Troubleshooting Guide

#### Common Issues and Solutions

1. **Container App Authentication Errors**
   ```bash
   # Check ACR credentials
   az acr credential show --name <acr-name>
   
   # Reset registry configuration
   az containerapp registry set --name <app-name> --server <acr-server> --username <user> --password <pass>
   ```

2. **Application Startup Failures**
   ```bash
   # Check container logs
   az containerapp logs show --name <app-name> --resource-group <rg-name> --tail 50
   
   # Verify environment variables
   az containerapp show --name <app-name> --query "properties.template.containers[0].env"
   ```

3. **GitHub Actions Build Failures**
   - Verify Azure credentials in GitHub secrets
   - Check ARM template syntax and resource naming
   - Ensure Docker build context includes all required files

4. **Network Connectivity Issues**
   - Verify Container App ingress configuration
   - Check target port matches application port
   - Ensure external ingress is enabled for public access

This deployment log serves as a comprehensive reference for future deployments and troubleshooting, capturing all the critical lessons learned during the successful Azure Container Apps deployment of MynaAPI.
