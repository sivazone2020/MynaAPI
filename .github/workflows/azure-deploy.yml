name: MynaAPI - Azure Container Apps Deployment

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

permissions:
  contents: read
  security-events: write
  actions: read
  id-token: write

env:
  AZURE_SUBSCRIPTION_ID: e584d9a6-2115-4a9b-a5d4-3d1948b95377
  PROJECT_NAME: mynaapi
  AZURE_LOCATION: eastus

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Basic syntax check
      run: |
        python -m py_compile app/main.py
        echo "Basic syntax check passed"

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan]
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    outputs:
      container-app-url: ${{ steps.get-url.outputs.container-app-url }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Create Resource Group
      run: |
        az group create \
          --name ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-rg \
          --location ${{ env.AZURE_LOCATION }} \
          --subscription ${{ env.AZURE_SUBSCRIPTION_ID }}
        
    - name: Deploy ARM template
      id: deploy
      uses: azure/arm-deploy@v1
      with:
        subscriptionId: ${{ env.AZURE_SUBSCRIPTION_ID }}
        resourceGroupName: ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-rg
        template: ./deployment/azure/main.json
        parameters: ./deployment/azure/parameters-${{ github.event.inputs.environment || 'dev' }}.json
        failOnStdErr: false
        
    - name: Create Container App
      run: |
        # Create a simple Container App with nginx
        az containerapp create \
          --name ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-app \
          --resource-group ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-rg \
          --environment ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-env \
          --image nginx:alpine \
          --target-port 80 \
          --ingress external \
          --cpu 1 \
          --memory 2Gi \
          --min-replicas 1 \
          --max-replicas 3

    - name: Get Container App URL
      id: get-url
      run: |
        app_url=$(az containerapp show --name ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-app --resource-group ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-rg --query "properties.configuration.ingress.fqdn" -o tsv)
        echo "container-app-url=https://$app_url" >> $GITHUB_OUTPUT

  build-container:
    name: Build Container Image
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Get ACR credentials and login
      run: |
        # Get ACR login server
        ACR_NAME="${{ env.PROJECT_NAME }}${{ github.event.inputs.environment || 'dev' }}acr"
        
        # Login to ACR using Azure CLI
        az acr login --name $ACR_NAME
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.PROJECT_NAME }}${{ github.event.inputs.environment || 'dev' }}acr.azurecr.io/${{ env.PROJECT_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VERSION=${{ github.sha }}

  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [build-container]
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    environment: ${{ github.event.inputs.environment || 'dev' }}
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Update Container App with new image
      run: |
        # Get ACR admin credentials
        ACR_NAME="${{ env.PROJECT_NAME }}${{ github.event.inputs.environment || 'dev' }}acr"
        ACR_USERNAME=$(az acr credential show --name $ACR_NAME --query username -o tsv)
        ACR_PASSWORD=$(az acr credential show --name $ACR_NAME --query passwords[0].value -o tsv)
        
        echo "ACR Name: $ACR_NAME"
        echo "ACR Username: $ACR_USERNAME"
        echo "Registry Server: ${{ env.PROJECT_NAME }}${{ github.event.inputs.environment || 'dev' }}acr.azurecr.io"
        
        # Set registry configuration FIRST to ensure authentication
        echo "Setting registry credentials..."
        az containerapp registry set \
          --name ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-app \
          --resource-group ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-rg \
          --server ${{ env.PROJECT_NAME }}${{ github.event.inputs.environment || 'dev' }}acr.azurecr.io \
          --username $ACR_USERNAME \
          --password $ACR_PASSWORD
          
        # Wait longer for credentials to propagate in Azure
        echo "Waiting for credentials to propagate in Azure..."
        sleep 100
        
        # Verify the registry configuration was applied
        echo "Verifying registry configuration..."
        az containerapp show \
          --name ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-app \
          --resource-group ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-rg \
          --query "properties.configuration.registries" -o table
          
        # Additional wait after verification
        echo "Final wait before image update..."
        sleep 15
          
        # Now update container app image with retry logic
        echo "Updating container app image..."
        # Use shortened SHA to match the Docker tag format
        SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
        IMAGE_TAG="${{ github.ref_name }}-${SHORT_SHA}"
        FULL_IMAGE="${{ env.PROJECT_NAME }}${{ github.event.inputs.environment || 'dev' }}acr.azurecr.io/${{ env.PROJECT_NAME }}:${IMAGE_TAG}"
        
        echo "Using image: $FULL_IMAGE"
        
        for i in {1..3}; do
          echo "Attempt $i of 3..."
          if az containerapp update \
            --name ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-app \
            --resource-group ${{ env.PROJECT_NAME }}-${{ github.event.inputs.environment || 'dev' }}-rg \
            --image "$FULL_IMAGE" \
            --subscription ${{ env.AZURE_SUBSCRIPTION_ID }}; then
            echo "Container app update successful!"
            break
          else
            echo "Attempt $i failed. Waiting before retry..."
            if [ $i -lt 3 ]; then
              sleep 60
            else
              echo "All attempts failed!"
              exit 1
            fi
          fi
        done

  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-application]
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Wait for deployment
      run: sleep 30
      
    - name: Health Check
      run: |
        app_url="${{ needs.deploy-infrastructure.outputs.container-app-url }}"
        echo "Testing health endpoint: $app_url/health"
        
        # Wait for app to be ready (max 5 minutes)
        for i in {1..30}; do
          if curl -f "$app_url/health" > /dev/null 2>&1; then
            echo "Health check passed!"
            break
          fi
          echo "Attempt $i: Health check failed, retrying in 10s..."
          sleep 10
        done
        
        # Final health check
        curl -f "$app_url/health" || exit 1
        
    - name: API Endpoint Tests
      run: |
        app_url="${{ needs.deploy-infrastructure.outputs.container-app-url }}"
        
        # Test API documentation endpoint
        echo "Testing API docs endpoint: $app_url/docs"
        curl -f "$app_url/docs" > /dev/null
        
        echo "Smoke tests completed successfully!"

  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-application, smoke-tests]
    if: failure() && (github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && github.ref == 'refs/heads/main'))
    
    steps:
    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    - name: Cleanup Failed Deployment
      run: |
        if [ "${{ github.event.inputs.environment }}" = "prod" ] || [ "${{ github.ref }}" = "refs/heads/main" ]; then
          resource_group="${{ env.PROJECT_NAME }}-prod-rg"
        else
          resource_group="${{ env.PROJECT_NAME }}-dev-rg"
        fi
        
        echo "Deployment failed. Consider manual cleanup of resource group: $resource_group"
        # Uncomment the following line if you want automatic cleanup on failure
        # az group delete --name $resource_group --yes --no-wait
